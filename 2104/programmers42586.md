
## 기능개발

### 문제 설명
  > 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.  
>
또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.  
>
먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.  

  ### 제한사항
  >1. 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
2. 작업 진도는 100 미만의 자연수입니다.
3. 작업 속도는 100 이하의 자연수입니다.
4. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.
  
  ### 입출력 예
  | progresses               | speeds             | return    |
  | ------------------------ | ------------------ | --------- |
  | [93, 30, 55]             | [1, 30, 5]         | [2, 1]    |
  | [95, 90, 99, 99, 80, 99] | [1, 1, 1, 1, 1, 1] | [1, 3, 2] |

 ### 입출력 예 설명
 #### 입출력 예 #1
>첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
>두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
>세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.
>
따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.

#### 입출력 예 #2
>모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.
>
따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.
```js
function solution(progresses, speeds) {
    var answer = [];
    return answer;
}
```
```js
/*
progress는 진행절차, speeds는 하루에 진행되는 속도
progress[0]부터 배포가 시작되야 한다. progressse가 100이 되어도 바로 배포할 수 없다.
if(progresses[0] == 100) answer.push(progresses.shift()))
progresses요소는 100까지만 채워지도록 한다. progresses[0]이 100이 되면 answer에 첫 요소에 +1 한다.
남은 progresses는 재귀로 돌린다.
[93 30 55][1 30 5] 시작
[94 60 60] 1일차
[95 90 65] 2일차
[96 100+ 70] 3일차, [1]번째 요소 100달성, 기다림
[99 100 75] 4일차
[100+ 100 80] 5일차, [0]번째 요소 100 달성, answer[0]에 +=1, progresses.shift() answer:[1]
[100 80] 아직 5일차, [0]번째 요소 100이니 answer[0]에 +=1, progresses.shift()] answer:[2]
[85] [90] [95] [100] 9일차에 남은 요소 100달성, answer[1]에 +=1, progresses.shift()answer:[2,1]
progresses.length == 0이므로 종료
*/

function solution(progresses, speeds) {
    var answer = [0];
    let remainDays = [];
    progresses.forEach((el, idx) => {
        remainDays.push(Math.ceil((100 - el) / speeds[idx]))
    })

    let cur = remainDays[0]
    for (let i = 0, j = 0; i < remainDays.length; i++) {
        if (remainDays[i] <= cur) {
            answer[j]++
        } else {
            cur = remainDays[i]
            answer[++j] = 1
        }
    }


    console.log(answer)
    /*
      진행완료까지 남은 작업일수를 구한다.
      배열의 [0]번째 값을 실제 경과일로 지정한다.
      남은 작업일수 배열의 길이만큼 반복하여 각 배열의 요소가 실제 경과일보다 작거나 같다면 그 작업은 진행이 완료된 것으로 본다.
      (경과일에 도달했거나 이미 완성되고 앞의 과정을 기다리는 중)
    
      배열의 요소가 경과일보다 크다면 그 작업은 아직 작업중인 것이다. 이전 작업과 같이 끝나지 않는다.
    
      끝나는 날이 [7,3,9]일 경우, [0]과 [1]은 같은 날 배포된다. [2]는 [0]과 [1]이 배포된 날 이후에 배포된다.
      [1,1,2,1,5,3]일 경우, [0]과 [1]은 같은 날 배포된다. [2]는 [0]과 [1]이 배포된 날 이후에 배포되며, 이 때 [2],[3]이 같이 배포된다. [4]는 [2],[3]이 배포된 날 이후에 배포되며, 이 때 [4],[5]가 같이 배포된다.
    */
}
solution([93, 30, 55], [1, 30, 5])//[2,1]
solution([95, 90, 99, 99, 80, 99], [1, 1, 1, 1, 1, 1])//[1,3,2]
solution([80, 30, 40, 55, 66, 21, 8, 25, 44, 77, 92], [20, 30, 50, 15, 20, 50, 22, 25, 35, 23, 2])
```
